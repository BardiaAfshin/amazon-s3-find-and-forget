AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: Amazon S3 Find and Forget State Machine

Globals:
  Function:
    Runtime: python3.7
    Timeout: 900
    Tracing: Active
    Layers: !Ref CommonLayers
    Environment:
      Variables:
        LogLevel: !Ref LogLevel
        LogGroupName: !Ref AuditLogGroup

Parameters:
  AthenaConcurrencyLimit:
    Description: How many Athena queries should be scheduled concurrently
    Type: Number
    Default: 20
  AthenaWorkGroup:
    Description: WorkGroup to use for Athena queries
    Type: String
    Default: primary
  AuditLogGroup:
    Type: String
  CommonLayers:
    Type: CommaDelimitedList
    Description: Common layers supplied to all functions
  DataMapperTableName:
    Description: Table name for Data Mapper Table
    Type: String
  DeletionQueueTableName:
    Description: Table name for Deletion Queue Table
    Type: String
  DeleteQueueUrl:
    Type: String
  DeleteServiceName:
    Type: String
  DeletionTasksMaxNumber:
    Type: Number
  ECSCluster:
    Type: String
  JobTableName:
    Description: Table name for Jobs Table
    Type: String
  LogLevel:
    Type: String
    Default: INFO
    AllowedValues:
    - CRITICAL
    - FATAL
    - ERROR
    - WARNING
    - INFO
    - DEBUG
    - NOTSET
  ReportsAccessControlAllowOriginOverride:
    Type: String
  StateMachinePrefix:
    Type: String
  WebUIOrigin:
    Type: String

Conditions:
  DefaultAccessControlOrigin: !Equals [!Ref ReportsAccessControlAllowOriginOverride, "false"]

Resources:
  StatesExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
            - !Sub states.${AWS::Region}.amazonaws.com
          Action: "sts:AssumeRole"
      Path: "/"
      Policies:
      - PolicyName: StatesExecutionPolicy
        PolicyDocument:
          Version: "2012-10-17"
          Statement:
          - Effect: Allow
            Action:
            - "lambda:InvokeFunction"
            Resource:
            - !GetAtt OldestExecutionCheck.Arn
            - !GetAtt ScanTable.Arn
            - !GetAtt ParseStateMachineOutput.Arn
            - !GetAtt CheckQueueSize.Arn
            - !GetAtt ExecuteQuery.Arn
            - !GetAtt CheckQueryStatus.Arn
            - !GetAtt SubmitQueryResults.Arn
            - !GetAtt GenerateQueries.Arn
            - !GetAtt OrchestrateECSServiceScaling.Arn
            - !GetAtt AggregateResults.Arn
            - !GetAtt WorkQueryQueue.Arn
            - !GetAtt DeleteQueueMessage.Arn
            - !GetAtt PurgeQueue.Arn
            - !GetAtt LogAuditEvent.Arn
            - !GetAtt GenerateReport.Arn
          - Effect: Allow
            Action:
            - "dynamodb:Query"
            - "dynamodb:GetItem"
            - "dynamodb:PutItem"
            - "dynamodb:DeleteItem"
            - "dynamodb:UpdateItem"
            Resource:
            - !Sub "arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${JobTableName}"
            - !Sub "arn:${AWS::Partition}:dynamodb:${AWS::Region}:${AWS::AccountId}:table/${DeletionQueueTableName}"
          - Effect: Allow
            Action:
            - "events:PutTargets"
            - "events:PutRule"
            - "events:DescribeRule"
            Resource: "*"
          - Effect: Allow
            Action:
            - "states:DescribeExecution"
            - "states:DescribeStateMachine"
            - "states:DescribeStateMachineForExecution"
            - "states:ListStateMachines"
            - "states:ListExecutions"
            Resource: "*"
          - Effect: Allow
            Action:
            - "states:StartExecution"
            Resource:
            - !Sub "arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StateMachinePrefix}*"

  AthenaStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub ${StateMachinePrefix}-AthenaStateMachine
      RoleArn: !GetAtt StatesExecutionRole.Arn
      DefinitionString: !Sub |-
        {
          "StartAt": "Execute Query",
          "States": {
            "Execute Query": {
              "Comment": "Start an Athena query asynchronously",
              "Type": "Task",
              "Parameters": {
                "QueryData.$": "$",
                "Bucket": "${ResultBucket}",
                "Prefix": "queries"
              },
              "Resource": "${ExecuteQuery.Arn}",
              "ResultPath": "$.QueryId",
              "Next": "Get Query Status",
              "Retry": [{
                 "ErrorEquals": [ "States.ALL" ],
                 "IntervalSeconds": 10,
                 "BackoffRate": 10,
                 "MaxAttempts": 2
              }],
              "Catch": [{
                  "ErrorEquals": ["States.ALL"],
                  "ResultPath": "$.ErrorDetails",
                  "Next": "Handle Error"
              }]
            },
            "Wait for Query": {
              "Comment": "Waits before checking again whether Athena is done",
              "Type": "Wait",
              "SecondsPath": "$.WaitDuration",
              "Next": "Get Query Status"
            },
            "Get Query Status": {
              "Comment": "Gets the status of the given Athena query",
              "Type": "Task",
              "Resource": "${CheckQueryStatus.Arn}",
              "InputPath": "$.QueryId",
              "ResultPath": "$.QueryStatus",
              "Next": "Query Complete?",
              "Catch": [{
                 "ErrorEquals": ["States.ALL"],
                 "ResultPath": "$.ErrorDetails",
                 "Next": "Handle Error"
              }]
            },
            "Query Complete?": {
              "Comment": "Check if the Athena query is still running",
              "Type": "Choice",
              "Choices": [
              {
                "Variable": "$.QueryStatus.State",
                "StringEquals": "SUCCEEDED",
                "Next": "Query Succeeded"
              },
              {
                "Or": [
                  {
                    "Variable": "$.QueryStatus.State",
                    "StringEquals": "FAILED"
                  },
                  {
                    "Variable": "$.QueryStatus.State",
                    "StringEquals": "CANCELLED"
                  }
                ],
                "Next": "Handle Error"
              }
              ],
              "Default": "Wait for Query"
            },
            "Query Succeeded": {
              "Comment": "The query was successful",
              "Type": "Pass",
              "Next": "Submit Query Results"
            },
            "Handle Error": {
              "Type": "Pass",
              "Parameters": {
                "Error.$": "$.ErrorDetails.Error",
                "Cause.$": "$.ErrorDetails.Cause",
                "State.$": "$"
              },
               "Next": "Log Error"
            },
            "Log Error": {
              "Comment": "Log the failure in the audit log",
              "Type": "Task",
              "Parameters": {
                "EventName": "QueryFailed",
                "EventData.$": "$",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$.State.JobId"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Query Failed"
            },
            "Query Failed": {
              "Comment": "The query was unsuccessful",
              "Type": "Fail"
            },
            "Submit Query Results": {
              "Comment": "Obtain the query results from S3 and send them to Fargate",
              "Type": "Task",
              "Resource": "${SubmitQueryResults.Arn}",
              "ResultPath": null,
              "Next": "Log Success",
              "Retry": [{
                 "ErrorEquals": [ "States.ALL" ],
                 "IntervalSeconds": 5,
                 "BackoffRate": 2.5,
                 "MaxAttempts": 1
              }],
              "Catch": [{
                 "ErrorEquals": ["States.ALL"],
                 "ResultPath": "$.ErrorDetails",
                 "Next": "Handle Error"
              }]
            },
            "Log Success": {
              "Comment": "Log the success in the audit log",
              "Type": "Task",
              "Parameters": {
                "EventName": "QuerySucceeded",
                "EventData.$": "$",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$.JobId"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "End": true,
              "Retry": [{
                 "ErrorEquals": [ "States.ALL" ],
                 "IntervalSeconds": 3,
                 "BackoffRate": 1.5,
                 "MaxAttempts": 1
              }]
            }
          }
        }

  DeleteStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub ${StateMachinePrefix}-DeletionStateMachine
      RoleArn: !GetAtt StatesExecutionRole.Arn
      DefinitionString: !Sub |-
        {
          "StartAt": "Fetch Queue Size",
          "States": {
            "Fetch Queue Size": {
              "Comment": "Checks the number of messages in the Object Deletion Queue",
              "Type": "Task",
              "Resource": "${CheckQueueSize.Arn}",
              "Parameters": {
                "QueueUrl": "${DeleteQueueUrl}"
              },
              "ResultPath": "$.Queue",
              "Next": "Adjust Deletion Service Instance Count",
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }]
            },
            "Adjust Deletion Service Instance Count": {
              "Comment": "Sets the desired instance count based on Object Deletion Queue size",
              "Type": "Task",
              "Resource": "${OrchestrateECSServiceScaling.Arn}",
              "Parameters": {
                "Cluster": "${ECSCluster}",
                "DeleteService": "${DeleteServiceName}",
                "DeletionTasksMaxNumber": ${DeletionTasksMaxNumber},
                "QueueSize.$": "$.Queue.Total"
              },
              "ResultPath": "$.DesiredCount",
              "Next": "Items in Queue?",
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }]
            },
            "Items in Queue?": {
              "Comment": "Checks if any tasks are being created/terminated",
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.DesiredCount",
                  "NumericEquals": 0,
                  "Next": "No"
                },
                {
                  "Variable": "$.DesiredCount",
                  "NumericGreaterThan": 0,
                  "Next": "Wait"
                }
              ],
              "Default": "Not sure, fail"
            },
            "Wait": {
              "Comment": "Waits before checking if the Object Deletion Queue is empty",
              "Type": "Wait",
              "SecondsPath": "$.WaitDuration",
              "Next": "Fetch Queue Size again"
            },
            "Fetch Queue Size again": {
              "Comment": "Checks the number of messages in the Object Deletion Queue",
              "Type": "Task",
              "Resource": "${CheckQueueSize.Arn}",
              "Parameters": {
                "QueueUrl": "${DeleteQueueUrl}"
              },
              "ResultPath": "$.Queue",
              "Next": "Queue is Empty?",
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }]
            },
            "Queue is Empty?": {
              "Comment": "Checks if the Total messages are 0",
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.Queue.Total",
                  "NumericEquals": 0,
                  "Next": "Adjust Deletion Service Instance Count"
                },
                {
                  "Variable": "$.Queue.Total",
                  "NumericGreaterThan": 0,
                  "Next": "Wait"
                }
              ],
              "Default": "Not sure, fail"
            },
            "Not sure, fail": {
              "Type": "Fail"
            },
            "No": {
              "Type": "Succeed"
            }
          }
        }

  StateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub ${StateMachinePrefix}-StateMachine
      DefinitionString: !Sub |-
        {
          "Comment": "State machine for processing the S3 Find and Forget deletion queue.",
          "StartAt": "Check is Oldest Execution",
          "States": {
            "Check is Oldest Execution": {
              "Comment": "Queries the Step Functions API to check if the current executions is the oldest",
              "Type": "Task",
              "Resource": "${OldestExecutionCheck.Arn}",
              "Parameters": {
                "ExecutionId.$": "$$.Execution.Id"
              },
              "ResultPath": "$.IsOldestExecution",
              "Next": "Should Start?"
            },
            "Wait": {
              "Comment": "Waits before checking again whether this is the current execution",
              "Type": "Wait",
              "Seconds": 120,
              "Next": "Check is Oldest Execution"
            },
            "Should Start?": {
              "Comment": "Check if this execution is the oldest running execution and proceed if so.",
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.IsOldestExecution",
                  "BooleanEquals": true,
                  "Next": "Update Job Status"
                },
                {
                  "Variable": "$.IsOldestExecution",
                  "BooleanEquals": false,
                  "Next": "Wait"
                }
              ],
              "Default": "Handle Error"
            },
            "Update Job Status": {
              "Type": "Task",
              "Resource": "arn:aws:states:::dynamodb:updateItem",
              "Parameters": {
                "TableName": "${JobTableName}",
                "Key": {
                  "JobId": {
                    "S.$": "$$.Execution.Name"
                  }
                },
                "UpdateExpression": "SET JobStatus = :status",
                "ExpressionAttributeValues": {
                  ":status": {
                    "S": "RUNNING"
                  }
                }
              },
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }],
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }],
              "Next": "Query Deletion Queue"
            },
            "Query Deletion Queue": {
              "Comment": "Scan the deletion queue table to obtain all users to be deleted ",
              "Type": "Task",
              "Resource": "${ScanTable.Arn}",
              "Parameters": {
                "TableName": "${DeletionQueueTableName}"
              },
              "ResultPath": "$.DeletionQueue",
              "Next": "Users in Queue?",
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }],
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Users in Queue?": {
              "Comment": "If the deletion queue is empty, exit gracefully. Otherwise, proceed to processing the queue.",
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.DeletionQueue.Count",
                  "NumericGreaterThan": 0,
                  "Next": "Yes"
                },
                {
                  "Variable": "$.DeletionQueue.Count",
                  "NumericEquals": 0,
                  "Next": "No"
                }
              ],
              "Default": "No"
            },
            "No": {
              "Comment": "No work to be done.",
              "Type": "Pass",
              "Next": "Generate Report"
            },
            "Yes": {
              "Comment": "Continue.",
              "Type": "Pass",
              "Next": "Purge Queues"
            },
            "Purge Queues": {
              "Type": "Parallel",
              "Next": "Get Data Mappers",
              "ResultPath": null,
              "Branches": [{
                "StartAt": "Purge Query Queue",
                "States": {
                  "Purge Query Queue": {
                    "Parameters": {
                      "QueueUrl": "${QueryQueue}"
                    },
                    "Comment": "Purge the query queue",
                    "Type": "Task",
                    "Resource": "${PurgeQueue.Arn}",
                    "End": true,
                    "Retry": [{
                      "ErrorEquals": [ "States.ALL" ],
                      "IntervalSeconds": 60,
                      "MaxAttempts": 1
                    }]
                  }
                }
              }, {
               "StartAt": "Purge Deletion Queue",
               "States": {
                 "Purge Deletion Queue": {
                   "Parameters": {
                     "QueueUrl": "${DeleteQueueUrl}"
                   },
                   "Comment": "Purge the deletion queue",
                   "Type": "Task",
                   "Resource": "${PurgeQueue.Arn}",
                   "End": true,
                   "Retry": [{
                     "ErrorEquals": [ "States.ALL" ],
                     "IntervalSeconds": 60,
                     "MaxAttempts": 1
                   }]
                 }
               }
             }],
             "Catch": [{
               "ErrorEquals": ["States.ALL"],
               "ResultPath": "$.ErrorDetails",
               "Next": "Handle Error"
             }]
            },
            "Get Data Mappers": {
              "Comment": "Gets the list of data mappers",
              "Type": "Task",
              "Parameters": {
                "TableName": "${DataMapperTableName}"
              },
              "Resource": "${ScanTable.Arn}",
              "ResultPath": "$.DataMappers",
              "Next": "Start Find Phase",
              "Retry": [{
                "ErrorEquals": [ "States.ALL" ],
                "IntervalSeconds": 10,
                "MaxAttempts": 1
              }],
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Start Find Phase": {
              "Type": "Task",
              "Parameters": {
                "EventName": "FindPhaseStarted",
                "EventData.$": "$$.State.EnteredTime",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$$.Execution.Name"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Discover Files",
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Discover Files": {
              "Type": "Parallel",
              "Next": "End Find Phase",
              "ResultPath": null,
              "Branches": [
                {
                  "StartAt": "Filter Athena Data Mappers",
                  "States": {
                    "Filter Athena Data Mappers": {
                      "Parameters": {
                        "DataMappers.$": "$.DataMappers.Items[?(@.QueryExecutor=='athena')]",
                        "DeletionQueue.$": "$.DeletionQueue.Items",
                        "ExecutionId.$": "$$.Execution.Id",
                        "ExecutionName.$": "$$.Execution.Name"
                      },
                      "Comment": "Process Data Mappers with Athena as the query executor",
                      "Type": "Pass",
                      "Next": "Generate Queries"
                    },
                    "Generate Queries": {
                      "Comment": "Process each of the Athena data mappers and populate the Athena query queue",
                      "Type": "Task",
                      "Resource": "${GenerateQueries.Arn}",
                      "ResultPath": null,
                      "Next": "Work Queue"
                    },
                    "Work Queue": {
                      "Comment": "Works the Object Deletion Queue by starting Athena State Machine executions",
                      "Type": "Task",
                      "Resource": "${WorkQueryQueue.Arn}",
                      "ResultPath": "$.RunningExecutions",
                      "Next": "Outstanding Queries?"
                    },
                    "Outstanding Queries?": {
                      "Comment": "Checks if any queries are yet to be ran or are in progress or if we need to wait for capacity",
                      "Type": "Choice",
                      "Choices": [
                        {
                          "Variable": "$.RunningExecutions.Total",
                          "NumericEquals": 0,
                          "Next": "Done"
                        },
                        {
                          "Variable": "$.RunningExecutions.Total",
                          "NumericLessThan": ${AthenaConcurrencyLimit},
                          "Next": "Wait for Queries"
                        }
                      ],
                      "Default": "Wait for Queries"
                    },
                    "Wait for Queries": {
                      "Comment": "Waits before rechecking if the Object Deletion Queue is empty",
                      "Type": "Wait",
                      "Seconds": 5,
                      "Next": "Work Queue"
                    },
                    "Done": {
                      "Type": "Pass",
                      "End": true
                    }
                  }
                }
              ],
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "End Find Phase": {
              "Type": "Task",
              "Parameters": {
                "EventName": "FindPhaseEnded",
                "EventData.$": "$$.State.EnteredTime",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$$.Execution.Name"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Start Forget Phase",
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Start Forget Phase": {
              "Type": "Task",
              "Parameters": {
                "EventName": "ForgetPhaseStarted",
                "EventData.$": "$$.State.EnteredTime",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$$.Execution.Name"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Start Fargate Workflow",
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Start Fargate Workflow": {
              "Type":"Task",
              "Resource":"arn:aws:states:::states:startExecution.sync",
              "Parameters":{
                "Input":{
                  "AWS_STEP_FUNCTIONS_STARTED_BY_EXECUTION_ID.$": "$$.Execution.Id",
                  "WaitDuration": 30
                },
                "StateMachineArn":"${DeleteStateMachine}",
                "Name.$": "$$.Execution.Name"
              },
              "ResultPath": null,
              "Next": "End Forget Phase",
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "End Forget Phase": {
              "Type": "Task",
              "Parameters": {
                "EventName": "ForgetPhaseEnded",
                "EventData.$": "$$.State.EnteredTime",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$$.Execution.Name"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Delete Queue Items",
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Delete Queue Items": {
              "Comment": "Deletes all items from the deletion queue",
              "Type": "Map",
              "Next": "Generate Report",
              "InputPath": "$.DeletionQueue.Items",
              "ItemsPath": "$",
              "ResultPath": null,
              "MaxConcurrency": 10,
              "Iterator": {
                "StartAt": "Delete Queue Item",
                "States": {
                  "Delete Queue Item": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::dynamodb:deleteItem",
                    "Parameters": {
                      "TableName": "${DeletionQueueTableName}",
                      "Key": {
                        "MatchId": {"S.$": "$.MatchId"}
                      }
                    },
                    "ResultPath": null,
                    "End": true,
                    "Retry": [{
                      "ErrorEquals": [ "States.ALL" ],
                      "IntervalSeconds": 10,
                      "MaxAttempts": 1
                    }]
                  }
                }
              },
              "Catch": [{
                "ErrorEquals": ["States.ALL"],
                "ResultPath": "$.ErrorDetails",
                "Next": "Handle Error"
              }]
            },
            "Generate Report": {
              "Comment": "Generates a report on the execution",
              "Type": "Task",
              "Parameters": {
                "JobId.$": "$$.Execution.Name",
                "JobStartTime.$": "$$.Execution.StartTime",
                "JobFinishTime.$": "$$.State.EnteredTime",
                "Bucket": "${ResultBucket}",
                "Input.$": "$"
              },
              "Resource": "${GenerateReport.Arn}",
              "End": true
            },
            "Handle Error": {
              "Type": "Pass",
              "Parameters": {
                "Error.$": "$.ErrorDetails.Error",
                "Cause.$": "$.ErrorDetails.Cause",
                "State.$": "$"
              },
              "Next": "Log Error"
            },
            "Log Error": {
              "Comment": "Log the failure in the audit log",
              "Type": "Task",
              "Parameters": {
                "EventName": "Exception",
                "EventData.$": "$",
                "StreamSuffix.$": "$$.Execution.Name",
                "JobId.$": "$$.Execution.Name"
              },
              "Resource": "${LogAuditEvent.Arn}",
              "ResultPath": null,
              "Next": "Generate Report"
            }
          }
        }
      RoleArn: !GetAtt StatesExecutionRole.Arn

  # Supporting Resources
  ResultBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      LifecycleConfiguration:
        Rules:
        - Id: ExpireQueryResults
          Prefix: queries
          Status: Enabled
          ExpirationInDays: '1'
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ["*"]
            AllowedMethods: [GET]
            AllowedOrigins:
              - !If
                - DefaultAccessControlOrigin
                - !Ref WebUIOrigin
                - !Ref ReportsAccessControlAllowOriginOverride
            Id: !Sub ${StateMachinePrefix}CorsRule
            MaxAge: 3600

  QueryQueue:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 120

  # Tasks
  OldestExecutionCheck:
    Type: AWS::Serverless::Function
    Properties:
      Handler: oldest_execution.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          StateMachineArn: !Sub arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StateMachinePrefix}-StateMachine
      Policies:
      - Statement:
        - Action:
          - "states:ListExecutions"
          Effect: "Allow"
          Resource: !Sub arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StateMachinePrefix}*

  ScanTable:
    Type: AWS::Serverless::Function
    Properties:
      Handler: scan_table.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - DynamoDBReadPolicy:
          TableName: !Ref DeletionQueueTableName
      - DynamoDBReadPolicy:
          TableName: !Ref DataMapperTableName

  ParseStateMachineOutput:
    Type: AWS::Serverless::Function
    Properties:
      Handler: parse_output.handler
      CodeUri: ../backend/lambdas/tasks/

  CheckQueueSize:
    Type: AWS::Serverless::Function
    Properties:
      Handler: check_queue_size.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - Statement:
        - Action:
          - "sqs:GetQueueAttributes"
          Effect: "Allow"
          Resource:
          - !GetAtt QueryQueue.Arn
          - !Sub
            - arn:${AWS::Partition}:sqs:${AWS::Region}:${AWS::AccountId}:${QueueName}
            - QueueName: !Select [4, !Split ["/", !Ref DeleteQueueUrl]]

  ExecuteQuery:
    Type: AWS::Serverless::Function
    Properties:
      Handler: execute_query.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          AthenaWorkGroup: !Ref AthenaWorkGroup
      Policies:
      - S3CrudPolicy:
          BucketName: !Ref ResultBucket
      - Statement:
        - Action:
          - "glue:BatchGetPartition"
          - "glue:GetDatabase*"
          - "glue:GetPartition*"
          - "glue:GetTable*"
          Effect: "Allow"
          Resource:
          - !Sub "arn:${AWS::Partition}:glue:*:*:catalog*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:database*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:table*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:partition*"
        - Action:
          - "athena:StartQueryExecution"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:athena:${AWS::Region}:${AWS::AccountId}:workgroup/${AthenaWorkGroup}"

  CheckQueryStatus:
    Type: AWS::Serverless::Function
    Properties:
      Handler: check_query_status.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - Statement:
        - Action:
          - "athena:GetQueryExecution"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:athena:${AWS::Region}:${AWS::AccountId}:workgroup/${AthenaWorkGroup}"

  SubmitQueryResults:
    Type: AWS::Serverless::Function
    Properties:
      Handler: submit_query_results.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          QueueUrl: !Ref DeleteQueueUrl
      Policies:
      - S3ReadPolicy:
          BucketName: !Ref ResultBucket
      - Statement:
        - Action:
          - "athena:GetQueryResults"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:athena:${AWS::Region}:${AWS::AccountId}:workgroup/${AthenaWorkGroup}"
        - Action:
          - "sqs:SendMessage"
          - "sqs:GetQueueAttributes"
          Effect: "Allow"
          Resource:
          - !GetAtt QueryQueue.Arn
          - !Sub
            - arn:${AWS::Partition}:sqs:${AWS::Region}:${AWS::AccountId}:${QueueName}
            - QueueName: !Select [4, !Split ["/", !Ref DeleteQueueUrl]]

  GenerateQueries:
    Type: AWS::Serverless::Function
    Properties:
      Handler: generate_queries.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          QueryQueue: !Ref QueryQueue
      Policies:
      - Statement:
        - Action:
          - "glue:BatchGetPartition"
          - "glue:GetDatabase*"
          - "glue:GetPartition*"
          - "glue:GetTable*"
          Effect: "Allow"
          Resource:
          - !Sub "arn:${AWS::Partition}:glue:*:*:catalog*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:database*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:table*"
          - !Sub "arn:${AWS::Partition}:glue:*:*:partition*"
        - Effect: Allow
          Action:
          - "sqs:SendMessage*"
          - "sqs:GetQueueAttributes"
          Resource:
          - !GetAtt QueryQueue.Arn

  OrchestrateECSServiceScaling:
    Type: AWS::Serverless::Function
    Properties:
      Handler: orchestrate_ecs_service_scaling.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - Statement:
        - Action:
          - "ecs:UpdateService"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:ecs:${AWS::Region}:${AWS::AccountId}:service/${ECSCluster}/${DeleteServiceName}"

  AggregateResults:
    Type: AWS::Serverless::Function
    Properties:
      Handler: aggregate_results.handler
      CodeUri: ../backend/lambdas/tasks/

  WorkQueryQueue:
    Type: AWS::Serverless::Function
    Properties:
      Handler: work_query_queue.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          AthenaConcurrencyLimit: !Ref AthenaConcurrencyLimit
          StateMachineArn: !Sub "arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StateMachinePrefix}-AthenaStateMachine"
          QueueUrl: !Ref QueryQueue
          WaitDuration: 15
      Policies:
      - Statement:
        - Action:
          - "states:StartExecution"
          - "states:DescribeExecution"
          Effect: Allow
          Resource:
          - !Sub "arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${StateMachinePrefix}-AthenaStateMachine"
          - !Sub "arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:execution:${StateMachinePrefix}-AthenaStateMachine:*"
        - Action:
          - "sqs:ReceiveMessage*"
          - "sqs:ChangeMessageVisibility"
          - "sqs:PurgeQueue"
          - "sqs:DeleteMessage"
          - "sqs:GetQueueAttributes"
          Effect: "Allow"
          Resource:
          - !GetAtt QueryQueue.Arn
        - Action:
          - "logs:Describe*"
          - "logs:Filter*"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:logs:*:*:*"

  DeleteQueueMessage:
    Type: AWS::Serverless::Function
    Properties:
      Handler: delete_message.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          QueueUrl: !Ref QueryQueue
      Policies:
      - Statement:
        - Action:
          - "sqs:DeleteMessage"
          - "sqs:GetQueueAttributes"
          Effect: "Allow"
          Resource: !GetAtt QueryQueue.Arn

  PurgeQueue:
    Type: AWS::Serverless::Function
    Properties:
      Handler: purge_queue.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - Statement:
        - Action:
          - "sqs:PurgeQueue"
          - "sqs:GetQueueAttributes"
          Effect: "Allow"
          Resource:
          - !GetAtt QueryQueue.Arn
          - !Sub
            - arn:${AWS::Partition}:sqs:${AWS::Region}:${AWS::AccountId}:${QueueName}
            - QueueName: !Select [4, !Split ["/", !Ref DeleteQueueUrl]]

  LogAuditEvent:
    Type: AWS::Serverless::Function
    Properties:
      Handler: log_audit_event.handler
      CodeUri: ../backend/lambdas/tasks/
      Policies:
      - Statement:
        - Action:
            - "logs:CreateLogStream"
            - "logs:DescribeLogStreams"
            - "logs:PutLogEvents"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/s3f2*"

  GenerateReport:
    Type: AWS::Serverless::Function
    Properties:
      Handler: generate_report.handler
      CodeUri: ../backend/lambdas/tasks/
      Environment:
        Variables:
          JobTableName: !Ref JobTableName
      Policies:
      - S3CrudPolicy:
          BucketName: !Ref ResultBucket
      - DynamoDBCrudPolicy:
          TableName: !Ref JobTableName
      - Statement:
        - Action:
          - "logs:DescribeLogGroups"
          - "logs:DescribeLogStreams"
          - "logs:DescribeQueries"
          - "logs:FilterLogEvents"
          - "logs:GetLogEvents"
          - "logs:GetLogGroupFields"
          - "logs:GetLogRecord"
          - "logs:GetQueryResults"
          - "logs:ListLogDeliveries"
          Effect: "Allow"
          Resource: !Sub "arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/s3f2*"

Outputs:
  AthenaExecutionRole:
    Value: !Ref ExecuteQueryRole
  AthenaExecutionRoleArn:
    Value: !GetAtt ExecuteQueryRole.Arn
  AthenaStateMachineArn:
    Value: !Ref AthenaStateMachine
  AuditLogGroup:
    Value: !Ref AuditLogGroup
  QueryQueueUrl:
    Value: !Ref QueryQueue
  ResultBucket:
    Value: !Ref ResultBucket
  StateMachineArn:
    Value: !Ref StateMachine
  StateMachineRoleArn:
    Value: !GetAtt StatesExecutionRole.Arn